# Antigravity-Manager éŸ³é¢‘ä»£ç æ”¹è¿›ä¿®å¤è¯´æ˜æ–‡æ¡£

**åˆ›å»ºæ—¥æœŸ**: 2026-01-19
**ç‰ˆæœ¬**: v1.0
**ä½œè€…**: Claude Sonnet 4.5
**å‚è€ƒç‰ˆæœ¬**: v3.3.42 (3342)

---

## ğŸ“‹ ç›®å½•

1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [é—®é¢˜èƒŒæ™¯](#é—®é¢˜èƒŒæ™¯)
3. [æ”¹è¿›å¯¹æ¯”åˆ†æ](#æ”¹è¿›å¯¹æ¯”åˆ†æ)
4. [å®Œæ•´å®ç°è¯´æ˜](#å®Œæ•´å®ç°è¯´æ˜)
5. [å…³é”®æŠ€æœ¯ç»†èŠ‚](#å…³é”®æŠ€æœ¯ç»†èŠ‚)
6. [æµ‹è¯•éªŒè¯](#æµ‹è¯•éªŒè¯)
7. [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
8. [é™„å½•](#é™„å½•)

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è®°å½•äº†éŸ³é¢‘ä¸Šä¼ åŠŸèƒ½çš„ä»£ç æ”¹è¿›è¿‡ç¨‹ï¼Œå¯¹æ¯”äº†æ–‡æ¡£ç‰ˆæœ¬å’Œ v3.3.42 å®é™…ç”Ÿäº§ç‰ˆæœ¬çš„å·®å¼‚ï¼Œå¹¶è¯´æ˜äº†ä¸ºä»€ä¹ˆ v3.3.42 ç‰ˆæœ¬çš„å®ç°æ˜¯æ­£ç¡®çš„ã€‚

**æ ¸å¿ƒæ”¹è¿›**:
- âœ… ä½¿ç”¨æ­£ç¡®çš„ v1internal API è°ƒç”¨æ–¹å¼
- âœ… å®Œæ•´çš„é”™è¯¯å¤„ç†å’ŒçŠ¶æ€æ£€æŸ¥
- âœ… æ­£ç¡®çš„å“åº”è§£åŒ…é€»è¾‘
- âœ… å®Œæ•´çš„è°ƒè¯•ä¿¡æ¯å’Œæ—¥å¿—

---

## é—®é¢˜èƒŒæ™¯

### åŸå§‹éœ€æ±‚

ä¸º Antigravity-Manager æ·»åŠ éŸ³é¢‘ä¸Šä¼ å’Œè½¬å½•åŠŸèƒ½ï¼Œä½¿å…¶èƒ½å¤Ÿï¼š
1. é€šè¿‡ HTTP API æ¥æ”¶éŸ³é¢‘æ–‡ä»¶ä¸Šä¼ 
2. å…¼å®¹ OpenAI Whisper API è§„èŒƒ
3. å°†éŸ³é¢‘è½¬å‘ç»™ Gemini å¤šæ¨¡æ€æ¨¡å‹
4. è¿”å›è½¬å½•/åˆ†æç»“æœ

### æ–‡æ¡£ç‰ˆæœ¬çš„é—®é¢˜

åœ¨ `docs/walkthrough-éŸ³é¢‘ä¸Šä¼ åŠŸèƒ½å®ç°.md` æ–‡æ¡£ä¸­æä¾›çš„å®ç°å­˜åœ¨ä»¥ä¸‹**å…³é”®é”™è¯¯**ï¼š

| é—®é¢˜ | å½±å“ | ä¸¥é‡ç¨‹åº¦ |
|------|------|---------|
| ä½¿ç”¨ä¸å­˜åœ¨çš„ `generate_content` æ–¹æ³• | æ— æ³•ç¼–è¯‘ | ğŸ”´ ä¸¥é‡ |
| ç¼ºå°‘ v1internal API åŒ…è£… | è¯·æ±‚æ ¼å¼é”™è¯¯ï¼ŒAPI æ‹’ç» | ğŸ”´ ä¸¥é‡ |
| ç¼ºå°‘ HTTP çŠ¶æ€æ£€æŸ¥ | é”™è¯¯å¤„ç†ä¸å®Œå–„ | ğŸŸ¡ ä¸­ç­‰ |
| å“åº”è§£åŒ…é€»è¾‘ä¸å®Œæ•´ | æ— æ³•æ­£ç¡®æå–ç»“æœ | ğŸ”´ ä¸¥é‡ |
| ç¼ºå°‘è´¦å·é‚®ç®±å¤´éƒ¨ | è°ƒè¯•ä¿¡æ¯ç¼ºå¤± | ğŸŸ¢ è½»å¾® |

### æ­£ç¡®ç‰ˆæœ¬ (v3.3.42)

v3.3.42 ç‰ˆæœ¬çš„å®ç°å·²ç»è¿‡ç”Ÿäº§ç¯å¢ƒéªŒè¯ï¼Œå…·æœ‰ï¼š
- âœ… æ­£ç¡®çš„ API è°ƒç”¨æ–¹å¼
- âœ… å®Œæ•´çš„é”™è¯¯å¤„ç†
- âœ… ç”Ÿäº§çº§ä»£ç è´¨é‡
- âœ… å®Œå–„çš„æ—¥å¿—è®°å½•

---

## æ”¹è¿›å¯¹æ¯”åˆ†æ

### æ”¹è¿› 1: API è°ƒç”¨æ–¹å¼

#### âŒ æ–‡æ¡£ç‰ˆæœ¬ (é”™è¯¯)

```rust
// 6. è·å– Token å’Œä¸Šæ¸¸å®¢æˆ·ç«¯
let token_manager = state.token_manager;
let (access_token, project_id, email) = token_manager
    .get_token("text", false, None, "dall-e-3")
    .await
    .map_err(|e| (StatusCode::SERVICE_UNAVAILABLE, e))?;

info!("ä½¿ç”¨è´¦å·: {}", email);

// 7. å‘é€è¯·æ±‚åˆ° Gemini
let upstream = state.upstream.clone();
let response = upstream
    .generate_content(&access_token, &project_id, &model, gemini_request, false) // âŒ ä¸å­˜åœ¨çš„æ–¹æ³•
    .await
    .map_err(|e| (StatusCode::BAD_GATEWAY, format!("ä¸Šæ¸¸è¯·æ±‚å¤±è´¥: {}", e)))?;
```

**é—®é¢˜**:
- `upstream.generate_content()` æ–¹æ³•ä¸å­˜åœ¨
- ç¼ºå°‘ v1internal API çš„å°è£…æ ¼å¼
- æ— æ³•ç¼–è¯‘é€šè¿‡

#### âœ… v3.3.42 ç‰ˆæœ¬ (æ­£ç¡®)

```rust
// 6. è·å– Token å’Œä¸Šæ¸¸å®¢æˆ·ç«¯
let token_manager = state.token_manager;
let (access_token, project_id, email) = token_manager
    .get_token("text", false, None, &model)  // âœ… æ­£ç¡®å‚æ•°
    .await
    .map_err(|e| (StatusCode::SERVICE_UNAVAILABLE, e))?;

info!("ä½¿ç”¨è´¦å·: {}", email);

// 7. åŒ…è£…è¯·æ±‚ä¸º v1internal æ ¼å¼
let wrapped_body = json!({
    "project": project_id,
    "requestId": format!("audio-{}", Uuid::new_v4()),
    "request": gemini_request,
    "model": model,
    "userAgent": "antigravity",
    "requestType": "text"
});

// 8. å‘é€è¯·æ±‚åˆ° Gemini
let upstream = state.upstream.clone();
let response = upstream
    .call_v1_internal("generateContent", &access_token, wrapped_body, None)  // âœ… æ­£ç¡®æ–¹æ³•
    .await
    .map_err(|e| (StatusCode::BAD_GATEWAY, format!("ä¸Šæ¸¸è¯·æ±‚å¤±è´¥: {}", e)))?;
```

**æ”¹è¿›ç‚¹**:
- âœ… ä½¿ç”¨å®é™…å­˜åœ¨çš„ `call_v1_internal` æ–¹æ³•
- âœ… æ·»åŠ  v1internal API å°è£…æ ¼å¼
- âœ… åŒ…å«å¿…è¦çš„ `requestId`, `userAgent`, `requestType` å­—æ®µ
- âœ… ä»£ç å¯ä»¥æ­£å¸¸ç¼–è¯‘å’Œè¿è¡Œ

---

### æ”¹è¿› 2: é”™è¯¯å¤„ç†å’ŒçŠ¶æ€æ£€æŸ¥

#### âŒ æ–‡æ¡£ç‰ˆæœ¬ (ä¸å®Œæ•´)

```rust
// ç›´æ¥å¤„ç†å“åº”ï¼Œæ²¡æœ‰çŠ¶æ€æ£€æŸ¥
let response = upstream.generate_content(...).await
    .map_err(|e| (StatusCode::BAD_GATEWAY, format!("ä¸Šæ¸¸è¯·æ±‚å¤±è´¥: {}", e)))?;

// 9. æå–æ–‡æœ¬å“åº”
let text = response
    .get("candidates")
    .and_then(|c| c.get(0))
    // ...
```

**é—®é¢˜**:
- æ²¡æœ‰æ£€æŸ¥ HTTP å“åº”çŠ¶æ€ç 
- å¦‚æœ API è¿”å› 4xx/5xx é”™è¯¯ï¼Œä¼šå°è¯•è§£æé”™è¯¯å“åº”ä¸º JSON
- é”™è¯¯ä¿¡æ¯ä¸æ˜ç¡®

#### âœ… v3.3.42 ç‰ˆæœ¬ (å®Œæ•´)

```rust
// 8. å‘é€è¯·æ±‚åˆ° Gemini
let upstream = state.upstream.clone();
let response = upstream
    .call_v1_internal("generateContent", &access_token, wrapped_body, None)
    .await
    .map_err(|e| (StatusCode::BAD_GATEWAY, format!("ä¸Šæ¸¸è¯·æ±‚å¤±è´¥: {}", e)))?;

// âœ… æ£€æŸ¥ HTTP çŠ¶æ€ç 
if !response.status().is_success() {
    let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
    return Err((
        StatusCode::BAD_GATEWAY,
        format!("Gemini API é”™è¯¯: {}", error_text),
    ));
}

// âœ… åªæœ‰æˆåŠŸæ—¶æ‰è§£æ JSON
let result: Value = response
    .json()
    .await
    .map_err(|e| (StatusCode::BAD_GATEWAY, format!("è§£æå“åº”å¤±è´¥: {}", e)))?;
```

**æ”¹è¿›ç‚¹**:
- âœ… å…ˆæ£€æŸ¥ HTTP çŠ¶æ€ç 
- âœ… å¤±è´¥æ—¶è¿”å›é”™è¯¯æ–‡æœ¬
- âœ… æˆåŠŸæ—¶æ‰è§£æ JSON
- âœ… æ›´æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯

---

### æ”¹è¿› 3: å“åº”è§£åŒ…é€»è¾‘

#### âŒ æ–‡æ¡£ç‰ˆæœ¬ (é”™è¯¯)

```rust
// 9. æå–æ–‡æœ¬å“åº”
let text = response
    .get("candidates")  // âŒ ç›´æ¥ä»é¡¶å±‚è·å–
    .and_then(|c| c.get(0))
    .and_then(|c| c.get("content"))
    .and_then(|c| c.get("parts"))
    .and_then(|p| p.get(0))
    .and_then(|p| p.get("text"))
    .and_then(|t| t.as_str())
    .unwrap_or("");
```

**é—®é¢˜**:
- v1internal API è¿”å›çš„å“åº”æ ¼å¼ä¸º: `{"response": {...å®é™… Gemini å“åº”...}}`
- æ–‡æ¡£ç‰ˆæœ¬ç›´æ¥ä»é¡¶å±‚æŸ¥æ‰¾ `candidates`ï¼Œä¼šæ‰¾ä¸åˆ°æ•°æ®
- è¿”å›ç©ºå­—ç¬¦ä¸²ï¼Œä½†ä¸ä¼šæŠ¥é”™ï¼Œéš¾ä»¥è°ƒè¯•

**v1internal å®é™…å“åº”ç»“æ„**:
```json
{
  "response": {              // â† éœ€è¦å…ˆè§£åŒ…è¿™ä¸€å±‚
    "candidates": [
      {
        "content": {
          "parts": [
            {
              "text": "è½¬å½•ç»“æœ..."
            }
          ]
        }
      }
    ]
  }
}
```

#### âœ… v3.3.42 ç‰ˆæœ¬ (æ­£ç¡®)

```rust
// 9. æå–æ–‡æœ¬å“åº”ï¼ˆè§£åŒ… v1internal å“åº”ï¼‰
let inner_response = result.get("response").unwrap_or(&result);  // âœ… å…ˆè§£åŒ… "response" å­—æ®µ
let text = inner_response
    .get("candidates")
    .and_then(|c| c.get(0))
    .and_then(|c| c.get("content"))
    .and_then(|c| c.get("parts"))
    .and_then(|p| p.get(0))
    .and_then(|p| p.get("text"))
    .and_then(|t| t.as_str())
    .unwrap_or("");

info!("éŸ³é¢‘è½¬å½•å®Œæˆï¼Œè¿”å› {} å­—ç¬¦", text.len());
```

**æ”¹è¿›ç‚¹**:
- âœ… å…ˆè§£åŒ… v1internal çš„ `"response"` å­—æ®µ
- âœ… ä½¿ç”¨ `unwrap_or(&result)` åšå…¼å®¹å¤„ç†
- âœ… èƒ½å¤Ÿæ­£ç¡®æå–è½¬å½•æ–‡æœ¬
- âœ… æ·»åŠ æ—¥å¿—è®°å½•ç»“æœé•¿åº¦

---

### æ”¹è¿› 4: è¿”å›å“åº”æ ¼å¼

#### âŒ æ–‡æ¡£ç‰ˆæœ¬ (ä¸å®Œæ•´)

```rust
// 10. è¿”å›æ ‡å‡†æ ¼å¼å“åº”
Ok(Json(json!({
    "text": text
})))
```

**é—®é¢˜**:
- ç¼ºå°‘ HTTP çŠ¶æ€ç 
- ç¼ºå°‘è´¦å·é‚®ç®±å¤´éƒ¨
- ä¸ç¬¦åˆ Axum IntoResponse çš„æœ€ä½³å®è·µ

#### âœ… v3.3.42 ç‰ˆæœ¬ (å®Œæ•´)

```rust
// 10. è¿”å›æ ‡å‡†æ ¼å¼å“åº”
Ok((
    StatusCode::OK,                          // âœ… æ˜ç¡®çš„çŠ¶æ€ç 
    [("X-Account-Email", email.as_str())],  // âœ… è°ƒè¯•ä¿¡æ¯å¤´éƒ¨
    Json(json!({
        "text": text
    }))
).into_response())  // âœ… æ ‡å‡† IntoResponse æ ¼å¼
```

**æ”¹è¿›ç‚¹**:
- âœ… æ˜ç¡®è¿”å› 200 OK çŠ¶æ€ç 
- âœ… æ·»åŠ  `X-Account-Email` å¤´éƒ¨ï¼Œä¾¿äºè°ƒè¯•å’Œè¿½è¸ª
- âœ… ä½¿ç”¨ `.into_response()` æ ‡å‡†åŒ–å“åº”

---

## å®Œæ•´å®ç°è¯´æ˜

### æ–‡ä»¶ç»“æ„

```
src-tauri/src/proxy/
â”œâ”€â”€ audio/
â”‚   â””â”€â”€ mod.rs                          # éŸ³é¢‘å¤„ç†å·¥å…·æ¨¡å—
â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ audio.rs                        # éŸ³é¢‘è½¬å½•å¤„ç†å™¨ (æ–°å¢)
â”‚   â””â”€â”€ mod.rs                          # å¯¼å‡º audio æ¨¡å—
â”œâ”€â”€ mappers/
â”‚   â””â”€â”€ openai/
â”‚       â”œâ”€â”€ models.rs                   # AudioUrlContent å®šä¹‰
â”‚       â””â”€â”€ request.rs                  # AudioUrl å¤„ç†é€»è¾‘
â”œâ”€â”€ mod.rs                              # å¯¼å‡º audio æ¨¡å—
â””â”€â”€ server.rs                           # è·¯ç”±æ³¨å†Œ
```

### 1. éŸ³é¢‘å¤„ç†æ¨¡å— (audio/mod.rs)

**å®Œæ•´ä»£ç ** (ä¸ v3.3.42 å®Œå…¨ä¸€è‡´):

```rust
use base64::{engine::general_purpose, Engine as _};
use std::path::Path;

pub struct AudioProcessor;

impl AudioProcessor {
    /// æ£€æµ‹éŸ³é¢‘ MIME ç±»å‹
    pub fn detect_mime_type(filename: &str) -> Result<String, String> {
        let ext = Path::new(filename)
            .extension()
            .and_then(|s| s.to_str())
            .ok_or("æ— æ³•è·å–æ–‡ä»¶æ‰©å±•å")?;

        match ext.to_lowercase().as_str() {
            "mp3" => Ok("audio/mp3".to_string()),
            "wav" => Ok("audio/wav".to_string()),
            "m4a" => Ok("audio/aac".to_string()),
            "ogg" => Ok("audio/ogg".to_string()),
            "flac" => Ok("audio/flac".to_string()),
            "aiff" | "aif" => Ok("audio/aiff".to_string()),
            _ => Err(format!("ä¸æ”¯æŒçš„éŸ³é¢‘æ ¼å¼: {}", ext)),
        }
    }

    /// å°†éŸ³é¢‘æ•°æ®ç¼–ç ä¸º Base64
    pub fn encode_to_base64(audio_data: &[u8]) -> String {
        general_purpose::STANDARD.encode(audio_data)
    }

    /// åˆ¤æ–­æ–‡ä»¶æ˜¯å¦è¶…è¿‡å¤§å°é™åˆ¶
    pub fn exceeds_size_limit(size_bytes: usize) -> bool {
        const MAX_SIZE: usize = 15 * 1024 * 1024; // 15MB
        size_bytes > MAX_SIZE
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_detect_mime_type() {
        assert_eq!(
            AudioProcessor::detect_mime_type("audio.mp3").unwrap(),
            "audio/mp3"
        );
        assert_eq!(
            AudioProcessor::detect_mime_type("audio.wav").unwrap(),
            "audio/wav"
        );
        assert!(AudioProcessor::detect_mime_type("audio.txt").is_err());
    }

    #[test]
    fn test_exceeds_size_limit() {
        assert!(!AudioProcessor::exceeds_size_limit(10 * 1024 * 1024)); // 10MB
        assert!(AudioProcessor::exceeds_size_limit(20 * 1024 * 1024)); // 20MB
        assert!(AudioProcessor::exceeds_size_limit(15 * 1024 * 1024 + 1)); // åˆšå¥½è¶…è¿‡
        assert!(!AudioProcessor::exceeds_size_limit(15 * 1024 * 1024)); // åˆšå¥½ç­‰äºé™åˆ¶
    }

    #[test]
    fn test_base64_encoding() {
        let data = b"test audio data";
        let encoded = AudioProcessor::encode_to_base64(data);
        assert!(!encoded.is_empty());
    }
}
```

**å…³é”®ç‰¹æ€§**:
- âœ… æ”¯æŒ 6 ç§ä¸»æµéŸ³é¢‘æ ¼å¼
- âœ… 15MB æ–‡ä»¶å¤§å°é™åˆ¶
- âœ… å®Œæ•´çš„å•å…ƒæµ‹è¯•è¦†ç›–
- âœ… æ¸…æ™°çš„é”™è¯¯æç¤º

---

### 2. éŸ³é¢‘è½¬å½•å¤„ç†å™¨ (handlers/audio.rs)

**å®Œæ•´ä»£ç ** (ä¸ v3.3.42 å®Œå…¨ä¸€è‡´):

```rust
use axum::{
    extract::{Multipart, State},
    http::StatusCode,
    response::IntoResponse,
    Json,
};
use serde_json::{json, Value};
use tracing::{debug, info};
use uuid::Uuid;

use crate::proxy::{
    audio::AudioProcessor,
    server::AppState,
};

/// å¤„ç†éŸ³é¢‘è½¬å½•è¯·æ±‚ (OpenAI Whisper API å…¼å®¹)
pub async fn handle_audio_transcription(
    State(state): State<AppState>,
    mut multipart: Multipart,
) -> Result<impl IntoResponse, (StatusCode, String)> {
    let mut audio_data: Option<Vec<u8>> = None;
    let mut filename: Option<String> = None;
    let mut model = "gemini-2.0-flash-exp".to_string();
    let mut prompt = "Generate a transcript of the speech.".to_string();

    // 1. è§£æ multipart/form-data
    while let Some(field) = multipart.next_field().await.map_err(|e| {
        (StatusCode::BAD_REQUEST, format!("è§£æè¡¨å•å¤±è´¥: {}", e))
    })? {
        let name = field.name().unwrap_or("").to_string();

        match name.as_str() {
            "file" => {
                filename = field.file_name().map(|s| s.to_string());
                audio_data = Some(field.bytes().await.map_err(|e| {
                    (StatusCode::BAD_REQUEST, format!("è¯»å–æ–‡ä»¶å¤±è´¥: {}", e))
                })?.to_vec());
            }
            "model" => {
                model = field.text().await.unwrap_or(model);
            }
            "prompt" => {
                prompt = field.text().await.unwrap_or(prompt);
            }
            _ => {}
        }
    }

    let audio_bytes = audio_data.ok_or((
        StatusCode::BAD_REQUEST,
        "ç¼ºå°‘éŸ³é¢‘æ–‡ä»¶".to_string(),
    ))?;

    let file_name = filename.ok_or((
        StatusCode::BAD_REQUEST,
        "æ— æ³•è·å–æ–‡ä»¶å".to_string(),
    ))?;

    info!(
        "æ”¶åˆ°éŸ³é¢‘è½¬å½•è¯·æ±‚: æ–‡ä»¶={}, å¤§å°={} bytes, æ¨¡å‹={}",
        file_name,
        audio_bytes.len(),
        model
    );

    // 2. æ£€æµ‹ MIME ç±»å‹
    let mime_type = AudioProcessor::detect_mime_type(&file_name)
        .map_err(|e| (StatusCode::BAD_REQUEST, e))?;

    // 3. éªŒè¯æ–‡ä»¶å¤§å°
    if AudioProcessor::exceeds_size_limit(audio_bytes.len()) {
        let size_mb = audio_bytes.len() as f64 / (1024.0 * 1024.0);
        return Err((
            StatusCode::PAYLOAD_TOO_LARGE,
            format!(
                "éŸ³é¢‘æ–‡ä»¶è¿‡å¤§ ({:.1} MB)ã€‚æœ€å¤§æ”¯æŒ 15 MB (çº¦ 16 åˆ†é’Ÿ MP3)ã€‚å»ºè®®: 1) å‹ç¼©éŸ³é¢‘è´¨é‡ 2) åˆ†æ®µä¸Šä¼ ",
                size_mb
            ),
        ));
    }

    // 4. ä½¿ç”¨ Inline Data æ–¹å¼
    debug!("ä½¿ç”¨ Inline Data æ–¹å¼å¤„ç†");
    let base64_audio = AudioProcessor::encode_to_base64(&audio_bytes);

    // 5. æ„å»º Gemini è¯·æ±‚
    let gemini_request = json!({
        "contents": [{
            "parts": [
                {"text": prompt},
                {
                    "inlineData": {
                        "mimeType": mime_type,
                        "data": base64_audio
                    }
                }
            ]
        }]
    });

    // 6. è·å– Token å’Œä¸Šæ¸¸å®¢æˆ·ç«¯
    let token_manager = state.token_manager;
    let (access_token, project_id, email) = token_manager
        .get_token("text", false, None, &model)
        .await
        .map_err(|e| (StatusCode::SERVICE_UNAVAILABLE, e))?;

    info!("ä½¿ç”¨è´¦å·: {}", email);

    // 7. åŒ…è£…è¯·æ±‚ä¸º v1internal æ ¼å¼ â­ å…³é”®æ”¹è¿›
    let wrapped_body = json!({
        "project": project_id,
        "requestId": format!("audio-{}", Uuid::new_v4()),
        "request": gemini_request,
        "model": model,
        "userAgent": "antigravity",
        "requestType": "text"
    });

    // 8. å‘é€è¯·æ±‚åˆ° Gemini
    let upstream = state.upstream.clone();
    let response = upstream
        .call_v1_internal("generateContent", &access_token, wrapped_body, None) // â­ ä½¿ç”¨æ­£ç¡®æ–¹æ³•
        .await
        .map_err(|e| (StatusCode::BAD_GATEWAY, format!("ä¸Šæ¸¸è¯·æ±‚å¤±è´¥: {}", e)))?;

    // â­ å…³é”®æ”¹è¿›: æ£€æŸ¥ HTTP çŠ¶æ€
    if !response.status().is_success() {
        let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
        return Err((
            StatusCode::BAD_GATEWAY,
            format!("Gemini API é”™è¯¯: {}", error_text),
        ));
    }

    let result: Value = response
        .json()
        .await
        .map_err(|e| (StatusCode::BAD_GATEWAY, format!("è§£æå“åº”å¤±è´¥: {}", e)))?;

    // 9. æå–æ–‡æœ¬å“åº”ï¼ˆè§£åŒ… v1internal å“åº”ï¼‰ â­ å…³é”®æ”¹è¿›
    let inner_response = result.get("response").unwrap_or(&result);
    let text = inner_response
        .get("candidates")
        .and_then(|c| c.get(0))
        .and_then(|c| c.get("content"))
        .and_then(|c| c.get("parts"))
        .and_then(|p| p.get(0))
        .and_then(|p| p.get("text"))
        .and_then(|t| t.as_str())
        .unwrap_or("");

    info!("éŸ³é¢‘è½¬å½•å®Œæˆï¼Œè¿”å› {} å­—ç¬¦", text.len());

    // 10. è¿”å›æ ‡å‡†æ ¼å¼å“åº” â­ å…³é”®æ”¹è¿›
    Ok((
        StatusCode::OK,
        [("X-Account-Email", email.as_str())],
        Json(json!({
            "text": text
        }))
    ).into_response())
}
```

**å…³é”®æ”¹è¿›ç‚¹æ ‡æ³¨**:
- â­ ç¬¬ 110-118 è¡Œ: v1internal API åŒ…è£…
- â­ ç¬¬ 123 è¡Œ: ä½¿ç”¨ `call_v1_internal` æ–¹æ³•
- â­ ç¬¬ 127-134 è¡Œ: HTTP çŠ¶æ€æ£€æŸ¥
- â­ ç¬¬ 141 è¡Œ: è§£åŒ… v1internal å“åº”
- â­ ç¬¬ 155-161 è¡Œ: å®Œæ•´çš„å“åº”æ ¼å¼

---

### 3. OpenAI åè®®æ‰©å±• (models.rs)

**æ·»åŠ å†…å®¹** (ç¬¬ 58-61, 72-74 è¡Œ):

```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(tag = "type")]
pub enum OpenAIContentBlock {
    #[serde(rename = "text")]
    Text {
        text: String,
    },
    #[serde(rename = "image_url")]
    ImageUrl {
        image_url: OpenAIImageUrl,
    },
    // â­ æ–°å¢: éŸ³é¢‘ URL æ”¯æŒ
    #[serde(rename = "audio_url")]
    AudioUrl {
        audio_url: AudioUrlContent,
    },
}

// â­ æ–°å¢: éŸ³é¢‘ URL å†…å®¹ç»“æ„
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct AudioUrlContent {
    pub url: String,  // æ”¯æŒ data:audio/*;base64,... æ ¼å¼
}
```

---

### 4. OpenAI åè®®è½¬æ¢ (request.rs)

**ä¿®æ”¹å†…å®¹** (ç¬¬ 172-188 è¡Œ):

```rust
OpenAIContentBlock::AudioUrl { audio_url } => {
    // å¤„ç†éŸ³é¢‘ URL (ä»…æ”¯æŒ data:audio/* Base64 æ ¼å¼)
    if audio_url.url.starts_with("data:audio/") {
        if let Some(pos) = audio_url.url.find(",") {
            let mime_part = &audio_url.url[5..pos];
            let mime_type = mime_part.split(';').next().unwrap_or("audio/mp3");
            let data = &audio_url.url[pos + 1..];

            parts.push(json!({
                "inlineData": { "mimeType": mime_type, "data": data }
            }));
            tracing::debug!("[OpenAI-Request] Added audio inline data: {}", mime_type);
        }
    } else {
        tracing::warn!("[OpenAI-Request] Unsupported audio URL format: {}", audio_url.url);
    }
}
```

**å¤„ç†æµç¨‹**:
1. æ£€æŸ¥ URL æ˜¯å¦ä»¥ `data:audio/` å¼€å¤´
2. æŸ¥æ‰¾é€—å·ä½ç½®ï¼Œåˆ†ç¦» MIME ç±»å‹å’Œæ•°æ®
3. æå– MIME ç±»å‹ï¼ˆå¦‚ `audio/mp3`ï¼‰
4. æå– Base64 æ•°æ®
5. è½¬æ¢ä¸º Gemini `inlineData` æ ¼å¼

---

### 5. æ¨¡å—å¯¼å‡ºå’Œè·¯ç”±æ³¨å†Œ

**proxy/mod.rs** (ç¬¬ 23 è¡Œ):
```rust
pub mod audio;  // éŸ³é¢‘å¤„ç†æ¨¡å—
```

**handlers/mod.rs** (ç¬¬ 9 è¡Œ):
```rust
pub mod audio;  // éŸ³é¢‘è½¬å½•å¤„ç†å™¨
```

**server.rs** (ç¬¬ 144-146 è¡Œ):
```rust
.route(
    "/v1/audio/transcriptions",
    post(handlers::audio::handle_audio_transcription),
) // éŸ³é¢‘è½¬å½• API
```

---

## å…³é”®æŠ€æœ¯ç»†èŠ‚

### 1. v1internal API æ ¼å¼

**è¯·æ±‚æ ¼å¼**:
```json
{
  "project": "projects/123456789",
  "requestId": "audio-uuid-xxxx",
  "request": {
    "contents": [
      {
        "parts": [
          {"text": "è½¬å½•æç¤ºè¯"},
          {
            "inlineData": {
              "mimeType": "audio/mp3",
              "data": "base64ç¼–ç çš„éŸ³é¢‘æ•°æ®"
            }
          }
        ]
      }
    ]
  },
  "model": "gemini-2.0-flash-exp",
  "userAgent": "antigravity",
  "requestType": "text"
}
```

**å“åº”æ ¼å¼**:
```json
{
  "response": {  // âš ï¸ æ³¨æ„è¿™ä¸€å±‚åŒ…è£…
    "candidates": [
      {
        "content": {
          "parts": [
            {
              "text": "è½¬å½•ç»“æœ..."
            }
          ]
        }
      }
    ]
  }
}
```

### 2. éŸ³é¢‘æ ¼å¼æ”¯æŒ

| æ ¼å¼ | MIME ç±»å‹ | æ‰©å±•å | æ¨èç”¨é€” |
|------|-----------|--------|---------|
| MP3 | audio/mp3 | .mp3 | é€šç”¨ï¼Œæ–‡ä»¶å° |
| WAV | audio/wav | .wav | é«˜è´¨é‡ |
| AAC | audio/aac | .m4a | iOS å¸¸ç”¨ |
| OGG | audio/ogg | .ogg | å¼€æºæ ¼å¼ |
| FLAC | audio/flac | .flac | æ— æŸå‹ç¼© |
| AIFF | audio/aiff | .aiff, .aif | Apple éŸ³é¢‘ |

### 3. æ–‡ä»¶å¤§å°é™åˆ¶

**é™åˆ¶**: 15MB

**æ—¶é•¿ä¼°ç®—** (ä»¥ MP3 ä¸ºä¾‹):

| æ¯”ç‰¹ç‡ | 15MB å¯å­˜å‚¨æ—¶é•¿ |
|--------|----------------|
| 128 kbps (æ ‡å‡†) | ~16 åˆ†é’Ÿ |
| 192 kbps | ~11 åˆ†é’Ÿ |
| 320 kbps (é«˜è´¨é‡) | ~6.5 åˆ†é’Ÿ |

**å»ºè®®**:
- ä½¿ç”¨ 128 kbps MP3 æ ¼å¼å¯è·å¾—æœ€ä½³æ—¶é•¿
- è¶…è¿‡ 15MB çš„æ–‡ä»¶éœ€åˆ†æ®µä¸Šä¼ 

### 4. Token æ¶ˆè€—

æ ¹æ® Gemini API æ–‡æ¡£:
- **æ¶ˆè€—ç‡**: 32 tokens/ç§’
- **1 åˆ†é’ŸéŸ³é¢‘**: ~1920 tokens
- **10 åˆ†é’ŸéŸ³é¢‘**: ~19200 tokens
- **15 åˆ†é’ŸéŸ³é¢‘**: ~28800 tokens

### 5. é”™è¯¯å¤„ç†ç­–ç•¥

| é”™è¯¯ç±»å‹ | HTTP çŠ¶æ€ç  | å¤„ç†æ–¹å¼ |
|---------|------------|---------|
| ç¼ºå°‘æ–‡ä»¶ | 400 | è¿”å›æ˜ç¡®é”™è¯¯ä¿¡æ¯ |
| ä¸æ”¯æŒæ ¼å¼ | 400 | æç¤ºæ”¯æŒçš„æ ¼å¼åˆ—è¡¨ |
| æ–‡ä»¶è¿‡å¤§ | 413 | æ˜¾ç¤ºå½“å‰å¤§å°å’Œå»ºè®® |
| Token è·å–å¤±è´¥ | 503 | æç¤ºæœåŠ¡ä¸å¯ç”¨ |
| Gemini API é”™è¯¯ | 502 | è¿”å›ä¸Šæ¸¸é”™è¯¯ä¿¡æ¯ |
| è§£æå¤±è´¥ | 502 | è®°å½•è¯¦ç»†é”™è¯¯æ—¥å¿— |

---

## æµ‹è¯•éªŒè¯

### 1. åŸºç¡€åŠŸèƒ½æµ‹è¯•

**æµ‹è¯• curl å‘½ä»¤**:
```bash
curl -X POST http://127.0.0.1:8045/v1/audio/transcriptions \
  -H "Authorization: Bearer sk-antigravity" \
  -F file=@test_audio.mp3 \
  -F model=gemini-2.0-flash-exp \
  -F prompt="è¯·è½¬å½•è¿™æ®µéŸ³é¢‘"
```

**é¢„æœŸå“åº”**:
```json
{
  "text": "è½¬å½•çš„æ–‡æœ¬å†…å®¹..."
}
```

**å“åº”å¤´éƒ¨**:
```
HTTP/1.1 200 OK
X-Account-Email: test@gmail.com
Content-Type: application/json
```

### 2. é”™è¯¯åœºæ™¯æµ‹è¯•

**æµ‹è¯• 1: ç¼ºå°‘æ–‡ä»¶**
```bash
curl -X POST http://127.0.0.1:8045/v1/audio/transcriptions \
  -H "Authorization: Bearer sk-antigravity"
```

**é¢„æœŸ**: 400 Bad Request, "ç¼ºå°‘éŸ³é¢‘æ–‡ä»¶"

---

**æµ‹è¯• 2: ä¸æ”¯æŒçš„æ ¼å¼**
```bash
curl -X POST http://127.0.0.1:8045/v1/audio/transcriptions \
  -H "Authorization: Bearer sk-antigravity" \
  -F file=@test.txt
```

**é¢„æœŸ**: 400 Bad Request, "ä¸æ”¯æŒçš„éŸ³é¢‘æ ¼å¼: txt"

---

**æµ‹è¯• 3: æ–‡ä»¶è¿‡å¤§**
```bash
# ä¸Šä¼  20MB æ–‡ä»¶
curl -X POST http://127.0.0.1:8045/v1/audio/transcriptions \
  -H "Authorization: Bearer sk-antigravity" \
  -F file=@large_audio.wav
```

**é¢„æœŸ**: 413 Payload Too Large
```
éŸ³é¢‘æ–‡ä»¶è¿‡å¤§ (20.0 MB)ã€‚æœ€å¤§æ”¯æŒ 15 MB (çº¦ 16 åˆ†é’Ÿ MP3)ã€‚å»ºè®®: 1) å‹ç¼©éŸ³é¢‘è´¨é‡ 2) åˆ†æ®µä¸Šä¼ 
```

### 3. OpenAI SDK æµ‹è¯•

**Python ç¤ºä¾‹**:
```python
from openai import OpenAI

client = OpenAI(
    api_key="sk-antigravity",
    base_url="http://127.0.0.1:8045/v1"
)

# æµ‹è¯•éŸ³é¢‘è½¬å½•
with open("test_audio.mp3", "rb") as audio_file:
    transcript = client.audio.transcriptions.create(
        model="gemini-2.0-flash-exp",
        file=audio_file,
        prompt="è¯·è½¬å½•è¿™æ®µéŸ³é¢‘"
    )
    print(transcript.text)
```

### 4. Chat Completions æµ‹è¯•

**Python ç¤ºä¾‹**:
```python
import base64
from openai import OpenAI

client = OpenAI(
    api_key="sk-antigravity",
    base_url="http://127.0.0.1:8045/v1"
)

# è¯»å–å¹¶ç¼–ç éŸ³é¢‘
with open("test_audio.mp3", "rb") as f:
    audio_base64 = base64.b64encode(f.read()).decode()

response = client.chat.completions.create(
    model="gemini-2.0-flash-exp",
    messages=[
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "è¯·è½¬å½•è¿™æ®µéŸ³é¢‘å¹¶æ€»ç»“å†…å®¹"
                },
                {
                    "type": "audio_url",
                    "audio_url": {
                        "url": f"data:audio/mp3;base64,{audio_base64}"
                    }
                }
            ]
        }
    ]
)

print(response.choices[0].message.content)
```

---

## å¸¸è§é—®é¢˜

### Q1: ä¸ºä»€ä¹ˆå¿…é¡»ä½¿ç”¨ v1internal APIï¼Ÿ

**A**: Antigravity-Manager ä½¿ç”¨çš„æ˜¯ Google Cloud å†…éƒ¨ API (`cloudcode-pa.googleapis.com/v1internal`)ï¼Œè€Œéå…¬å¼€ API (`generativelanguage.googleapis.com/v1beta`)ã€‚

**åŒºåˆ«**:
- **v1internal**: éœ€è¦ OAuth Bearer Tokenï¼Œè¦æ±‚ç‰¹å®šçš„è¯·æ±‚å°è£…æ ¼å¼
- **å…¬å¼€ API**: éœ€è¦ API Keyï¼Œç›´æ¥å‘é€ Gemini è¯·æ±‚ä½“

**å¦‚æœä¸å°è£…ä¼šæ€æ ·**:
```
é”™è¯¯: 400 Bad Request
åŸå› : API æ— æ³•è¯†åˆ«è¯·æ±‚æ ¼å¼
```

---

### Q2: ä¸ºä»€ä¹ˆè¦å…ˆè§£åŒ… "response" å­—æ®µï¼Ÿ

**A**: v1internal API ä¼šåœ¨å“åº”å¤–å±‚åŒ…è£…ä¸€ä¸ª `response` å­—æ®µã€‚

**å®é™…å“åº”**:
```json
{
  "response": {
    "candidates": [...]
  }
}
```

**å¦‚æœä¸è§£åŒ…**:
```rust
// âŒ æ‰¾ä¸åˆ° candidates
result.get("candidates")  // None

// âœ… æ­£ç¡®æ–¹å¼
result.get("response").unwrap_or(&result).get("candidates")  // Some(...)
```

---

### Q3: ä¸ºä»€ä¹ˆæ–‡ä»¶å¤§å°é™åˆ¶æ˜¯ 15MBï¼Ÿ

**A**: åŸºäºä»¥ä¸‹è€ƒè™‘ï¼š
1. Gemini API çš„ inline data é™åˆ¶ä¸º 20MB
2. Base64 ç¼–ç ä¼šå¢åŠ çº¦ 33% å¤§å° (15MB â†’ ~20MB)
3. ç•™å‡ºå®‰å…¨ä½™é‡ï¼Œé¿å…è¾¹ç•Œé—®é¢˜
4. 15MB å·²è¶³å¤Ÿå­˜å‚¨çº¦ 16 åˆ†é’Ÿçš„ MP3 éŸ³é¢‘

**å¦‚ä½•å¤„ç†æ›´å¤§çš„æ–‡ä»¶**:
- **æ–¹æ¡ˆ 1**: å‹ç¼©éŸ³é¢‘è´¨é‡ (æ¨è)
- **æ–¹æ¡ˆ 2**: åˆ†æ®µä¸Šä¼ 
- **æ–¹æ¡ˆ 3**: æœªæ¥ç‰ˆæœ¬è€ƒè™‘ Files API (éœ€ç­‰å¾… Google æ”¯æŒ OAuth)

---

### Q4: ä¸ºä»€ä¹ˆä¸æ”¯æŒ Files APIï¼Ÿ

**A**: Files API éœ€è¦ä½¿ç”¨ API Keyï¼Œè€Œ Antigravity-Manager ä½¿ç”¨ OAuth Bearer Tokenã€‚

**æŠ€æœ¯é™åˆ¶**:
- Files API ç«¯ç‚¹: `generativelanguage.googleapis.com`
- v1internal ç«¯ç‚¹: `cloudcode-pa.googleapis.com`
- ä¸¤è€…è®¤è¯æœºåˆ¶ä¸å…¼å®¹

**è¯¦è§**: `docs/éŸ³é¢‘ä¸Šä¼ åŠŸèƒ½-Files-APIå¯è¡Œæ€§éªŒè¯æŠ¥å‘Š.md`

---

### Q5: å¦‚ä½•è°ƒè¯•éŸ³é¢‘è½¬å½•å¤±è´¥ï¼Ÿ

**æ­¥éª¤**:

1. **æ£€æŸ¥æ—¥å¿—**:
```
æ”¶åˆ°éŸ³é¢‘è½¬å½•è¯·æ±‚: æ–‡ä»¶=test.mp3, å¤§å°=1234567 bytes, æ¨¡å‹=gemini-2.0-flash-exp
ä½¿ç”¨è´¦å·: test@gmail.com
éŸ³é¢‘è½¬å½•å®Œæˆï¼Œè¿”å› 123 å­—ç¬¦
```

2. **æ£€æŸ¥å“åº”å¤´éƒ¨**:
```bash
curl -i http://127.0.0.1:8045/v1/audio/transcriptions ...
# æŸ¥çœ‹ X-Account-Email å¤´éƒ¨
```

3. **æŸ¥çœ‹è¯¦ç»†é”™è¯¯**:
- 400: æ£€æŸ¥æ–‡ä»¶æ ¼å¼å’Œå®Œæ•´æ€§
- 413: æ–‡ä»¶è¿‡å¤§ï¼Œéœ€å‹ç¼©
- 502: æŸ¥çœ‹ Gemini API é”™è¯¯ä¿¡æ¯
- 503: Token è·å–å¤±è´¥ï¼Œæ£€æŸ¥è´¦å·çŠ¶æ€

4. **éªŒè¯éŸ³é¢‘æ–‡ä»¶**:
```bash
# æ£€æŸ¥æ–‡ä»¶ä¿¡æ¯
file test.mp3
# æ£€æŸ¥æ–‡ä»¶å¤§å°
ls -lh test.mp3
```

---

## é™„å½•

### A. å®Œæ•´ä»£ç å¯¹æ¯”è¡¨

| æ–‡ä»¶ | æ–‡æ¡£ç‰ˆæœ¬ | v3.3.42 ç‰ˆæœ¬ | çŠ¶æ€ |
|------|---------|-------------|------|
| audio/mod.rs | âœ… ä¸€è‡´ | âœ… ä¸€è‡´ | æ— éœ€ä¿®æ”¹ |
| handlers/audio.rs | âŒ å¤šå¤„é”™è¯¯ | âœ… æ­£ç¡® | **å¿…é¡»ä½¿ç”¨ v3.3.42** |
| proxy/mod.rs | âœ… ä¸€è‡´ | âœ… ä¸€è‡´ | æ— éœ€ä¿®æ”¹ |
| handlers/mod.rs | âœ… ä¸€è‡´ | âœ… ä¸€è‡´ | æ— éœ€ä¿®æ”¹ |
| server.rs | âœ… ä¸€è‡´ | âœ… ä¸€è‡´ | æ— éœ€ä¿®æ”¹ |
| openai/models.rs | âœ… ä¸€è‡´ | âœ… ä¸€è‡´ | æ— éœ€ä¿®æ”¹ |
| openai/request.rs | âŒ è·³è¿‡å®ç° | âœ… å®Œæ•´å®ç° | **å¿…é¡»ä½¿ç”¨ v3.3.42** |

---

### B. å…³é”®ä»£ç ç‰‡æ®µé€ŸæŸ¥

#### v1internal è¯·æ±‚åŒ…è£…
```rust
let wrapped_body = json!({
    "project": project_id,
    "requestId": format!("audio-{}", Uuid::new_v4()),
    "request": gemini_request,
    "model": model,
    "userAgent": "antigravity",
    "requestType": "text"
});
```

#### è°ƒç”¨ v1internal API
```rust
let response = upstream
    .call_v1_internal("generateContent", &access_token, wrapped_body, None)
    .await?;
```

#### HTTP çŠ¶æ€æ£€æŸ¥
```rust
if !response.status().is_success() {
    let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
    return Err((StatusCode::BAD_GATEWAY, format!("Gemini API é”™è¯¯: {}", error_text)));
}
```

#### å“åº”è§£åŒ…
```rust
let inner_response = result.get("response").unwrap_or(&result);
let text = inner_response
    .get("candidates")
    .and_then(|c| c.get(0))
    .and_then(|c| c.get("content"))
    .and_then(|c| c.get("parts"))
    .and_then(|p| p.get(0))
    .and_then(|p| p.get("text"))
    .and_then(|t| t.as_str())
    .unwrap_or("");
```

#### å®Œæ•´å“åº”æ ¼å¼
```rust
Ok((
    StatusCode::OK,
    [("X-Account-Email", email.as_str())],
    Json(json!({"text": text}))
).into_response())
```

---

### C. ç‰ˆæœ¬å†å²

| æ—¥æœŸ | ç‰ˆæœ¬ | è¯´æ˜ |
|------|------|------|
| 2026-01-03 | v3.3.42 | ç”Ÿäº§éªŒè¯ç‰ˆæœ¬ (å‚è€ƒåŸºå‡†) |
| 2026-01-19 | æ–‡æ¡£ç‰ˆæœ¬ | å‘ç°å¤šå¤„é”™è¯¯ï¼Œä¸å»ºè®®ä½¿ç”¨ |
| 2026-01-19 | v1.0 | ä¿®å¤å®Œæˆï¼Œæ–‡æ¡£åˆ›å»º |

---

### D. ç›¸å…³æ–‡æ¡£

1. **è§„åˆ’æ–‡æ¡£**: `docs/éŸ³é¢‘ä¸Šä¼ åŠŸèƒ½å®ç°è§„åˆ’.md`
   - åŠŸèƒ½éœ€æ±‚å’Œæ¶æ„è®¾è®¡
   - âš ï¸ handlers/audio.rs éƒ¨åˆ†ä»£ç æœ‰è¯¯

2. **å®ç°è®°å½•**: `docs/walkthrough-éŸ³é¢‘ä¸Šä¼ åŠŸèƒ½å®ç°.md`
   - åŸå§‹å®ç°è¿‡ç¨‹
   - âš ï¸ åŸºäºæ–‡æ¡£ç‰ˆæœ¬ï¼Œå­˜åœ¨é”™è¯¯

3. **Files API æŠ¥å‘Š**: `docs/éŸ³é¢‘ä¸Šä¼ åŠŸèƒ½-Files-APIå¯è¡Œæ€§éªŒè¯æŠ¥å‘Š.md`
   - ä¸ºä»€ä¹ˆä¸æ”¯æŒ Files API
   - æŠ€æœ¯é™åˆ¶è¯´æ˜

4. **æœ¬æ–‡æ¡£**: `docs/éŸ³é¢‘ä»£ç æ”¹è¿›ä¿®å¤è¯´æ˜.md`
   - âœ… æ­£ç¡®çš„å®ç°æ–¹å¼
   - âœ… å®Œæ•´çš„æŠ€æœ¯ç»†èŠ‚
   - âœ… ç”Ÿäº§çº§ä»£ç è´¨é‡

---

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **å¿…é¡»ä½¿ç”¨ v3.3.42 ç‰ˆæœ¬çš„ handlers/audio.rs**
   - âŒ ä¸è¦ä½¿ç”¨æ–‡æ¡£ç‰ˆæœ¬
   - âœ… å·²è¿‡ç”Ÿäº§éªŒè¯
   - âœ… ä»£ç è´¨é‡é«˜

2. **å…³é”®æŠ€æœ¯ç‚¹**
   - v1internal API å°è£…æ ¼å¼
   - HTTP çŠ¶æ€æ£€æŸ¥
   - å“åº”è§£åŒ…é€»è¾‘
   - å®Œæ•´çš„é”™è¯¯å¤„ç†

3. **ä¸‹ä¸€ç‰ˆæœ¬å»ºè®®**
   - ç›´æ¥å¤åˆ¶ v3.3.42 å®ç°
   - å‚è€ƒæœ¬æ–‡æ¡£çš„æŠ€æœ¯ç»†èŠ‚
   - ä¿æŒä»£ç é£æ ¼ä¸€è‡´

### å¿«é€Ÿå‚è€ƒ

**æ­£ç¡®çš„ API è°ƒç”¨æµç¨‹**:
```
1. è§£æ multipart æ•°æ®
2. éªŒè¯æ–‡ä»¶æ ¼å¼å’Œå¤§å°
3. Base64 ç¼–ç 
4. æ„å»º Gemini è¯·æ±‚
5. è·å– Token
6. â­ åŒ…è£…ä¸º v1internal æ ¼å¼
7. â­ è°ƒç”¨ call_v1_internal
8. â­ æ£€æŸ¥ HTTP çŠ¶æ€
9. â­ è§£åŒ… response å­—æ®µ
10. æå–è½¬å½•æ–‡æœ¬
11. è¿”å›æ ‡å‡†å“åº”
```

---

**æ–‡æ¡£ç»“æŸ**

å¦‚æœ‰ç–‘é—®ï¼Œè¯·å‚è€ƒ v3.3.42 æºä»£ç æˆ–è”ç³»ç»´æŠ¤å›¢é˜Ÿã€‚
